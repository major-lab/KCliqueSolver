package kcliquesolver.core.solvers;


import kcliquesolver.core.interfaces.AbstractStrategy;
import kcliquesolver.core.models.Problem;
import kcliquesolver.core.models.Solution;
import kcliquesolver.core.rng.RngStream;


import java.util.ArrayList;


/**
 * Used for sampling the solution space and benchmarking.
 */
public class MonteCarlo extends AbstractStrategy {
    private final long[] seeds;
    private boolean verbose;
    private int sampleSize;


    public MonteCarlo(int sampleSize, long[] seeds, boolean verbose) {
        // some assertions
        assert sampleSize > 0;

        this.seeds = seeds;
        this.verbose = verbose;
        this.sampleSize = sampleSize;
    }


    public static Solution generateSolutionMonteCarlo(Problem problem, RngStream stream) {
            ArrayList<Integer> genes = selectRandomAssignments(problem.getRanges(), stream);
            Solution solution = new Solution(genes, 0);
            solution.setScore(calculateSumOfPairs(solution, problem.getDistanceMatrix()));

        return solution;
    }


    /**
     * Generate solutions by Monte Carlo
     * Mostly used for debugging and get the distribution of solutions
     * @param problem instance of a consensus problem
     * @return sorted list of solutions, generated by Monte Carlo
     */
    public ArrayList<Solution> solve(Problem problem) {

        // initialize the stream
        RngStream stream = new RngStream();
        stream.setSeed(seeds);

        ArrayList<Solution> solutions = new ArrayList<>();
        double counter = 0.;
        for (int i = 0; i != sampleSize; ++i) {
            solutions.add(generateSolutionMonteCarlo(problem, stream));
        }
        return solutions;
    }

    @Override
    public boolean isVerbose() {
        return verbose;
    }


}
